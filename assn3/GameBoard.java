/**
 * GameBoard.java 
 * @author Mike Zastre
 * 
 * For use with Assignment #3, UVic CSC 115 (Spring 2018)
 * University of Victoria.
 */ 

import java.util.*;

/**
 * GameBoard creates a representation of the word-search game
 * board. Some of the methods to be completed by students
 * for assignment #3 can be found here.
 */
public class GameBoard {
    public static final int NUM_ROWS = 4;
    public static final int NUM_COLS = 4;

    private static String[] GAME_PIECES = {
        "RIFOBX", "IFEHEY", "DENOWS", "UTOKND",
        "HMSRAO", "LUPETS", "ACITOA", "YLGKUE",
        "QBMJOA", "EHISPN", "VETIGN", "BALIYT",
        "EZAVND", "RALESC", "UWILRG", "PACEMD"
    };

    private char[][] board;
    private boolean[][] visited;
	private Stack<String> wordPoint = new Stack<String>();

    /**
     * Accepts a string-array representation of the game
     * board, and initializes the board to this value.
     * @param start A one-dimensional array of strings. Each row
     * corresponds to a row in the gameboard. If there are
     * too few characters in a row for the board, or too few
     * rows for the whole board, then the '.' character is
     * substituted for that game board position.
     */
    public GameBoard(String[] start) {
        this.board = new char[NUM_ROWS][NUM_COLS];

        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLS; col++) {
                this.board[row][col] = (
                    (row < start.length && col < start[row].length()) ?
                     start[row].toUpperCase().charAt(col) : 
                     '.'
                 );
            }
        }

        this.visited = new boolean[NUM_ROWS][NUM_COLS];
    }


    /**
     * Creates a random game board based on the random seed
     * value given as a parameter and the game-board
     * strings at the start of the class.
     *
     * The seed provided is used to initialize the random-number
     * generator -- whenever the same seed is used for such an
     * initialization, the same sequence of random numbers will
     * be generated by that random object.
     *
     * Creating the board consists of a few steps:
     *
     * (a) The static string array GAME_PIECES consists of 16
     *     strings each with six letters. These 16 strings are
     *     first randomly shuffled amongst themselves (i.e., the
     *     content of each string is not modified, but the position
     *     of that string in GAME_PIECES may be changed).
     *
     * (b) After this first shuffle, the content within each string
     *     in GAME_PIECES is randomly shuffled.
     *
     * (c) With (a) and (b) done, we can now store a letter in
     *     each of the gameboard's letter squares (i.e., each
     *     square is actually a location within a 2D char array).
     *     The last set of nested loops in this method performs
     *     such a step, storing the first character of each string
     *     in GAME_PIECES into positions of the 2D char array
     *     (an instance variable) named "board".
     * @param seed The value to initialized the Random object
     * used to create the game board. 
     */     
    public GameBoard(long seed) {
        this.board = new char[NUM_ROWS][NUM_COLS];

        Random r = new Random(seed);
        shuffle(GAME_PIECES, r);

        for (int i = 0; i < GAME_PIECES.length; i++) {
            Character rowPieces[] = new Character[GAME_PIECES[i].length()];
            for (int pos = 0; pos < GAME_PIECES[i].length(); pos++) {
                rowPieces[pos] = GAME_PIECES[i].charAt(pos); 
            }
            shuffle(rowPieces, r);
            GAME_PIECES[i] = "";
            for (Character c : rowPieces) {
                GAME_PIECES[i] += c;
            }
        }

        int count = 0;
        for (int row = 0; row < NUM_ROWS; row++) {
            for (int col = 0; col < NUM_COLS; col++) {
                this.board[row][col] = GAME_PIECES[count].charAt(0);
                count++;
            }
        }

        this.visited = new boolean[NUM_ROWS][NUM_COLS];
    }


    /**
     * An implementation of the Fisher-Yates random shuffle,
     * also known as the Knuth shuffle. For more algorithm
     * details visit. For more details see http://bit.ly/1q6jhRh
     *
     * @param array A collection of values to be shuffled. The
     * values in this array will be moved within the array, and
     * this works given the nature of object references in Java. 
     * @param r An already-created instance of Random which
     * is used as a source of random integers as needed by the
     * algorithm. 
     */
    private void shuffle(Object array[], Random r) {
        for (int i = array.length - 1; i > 0; i--) {
            int index = r.nextInt(i + 1);
            Object temp = array[index];
            array[index] = array[i];
            array[i] = temp;
        }
    }


    /**
     * Creates a printable representation of the gameboard.
     * For examples of output from this method, please read
     * the assignment description.
     * @return Single string with representation of gameboard.
     */
    public String toString() {
        String result = "     0 1 2 3\n"
                      + "     -------\n";

        for (int row = 0; row < NUM_ROWS; row++) {
            result += "  " + row + ":";
            for (int col = 0; col < NUM_COLS; col++) {
                result += " " + board[row][col];
            } 
            result += "\n";
        }

        return result;
    }


    /**
     * Given the state of the given GameBoard instance, determine
     * whether or not the the given word is on the board.
     * @param word The word for which a search of the board
     * must be performed (i.e., recursive backtracking).
     * @return A string with the letter-square path through the
     * board the, when followed, will equal the letters in the
     * word. If the word *cannot* be found, then null is 
     * returned.
     */
    public String isWord(String word) {
    	Stack<String> p = new Stack<String> ();
    	
    	for (int row = 0; row < NUM_ROWS; row++) {
        	for (int col = 0; col < NUM_COLS; col++) {
                if (this.board[row][col] == word.charAt(0)) {
                	p.push("(" + row + "," + col + ")"); //word.substring(0,1)
                	if(findPath(word, p, row, col)){
                		String w = new String();
                		while(!p.empty()){
                			//System.out.println(wordPoint.peek());
                			wordPoint.push(p.pop());
                		}
                		w = "[" + wordPoint.pop();
                		while(!wordPoint.empty()){
                			//System.out.println(p.pop());
                			w = w + ", " + wordPoint.pop();
                		}
                		return w + "]";
                	} else {
                		return null;
                	}
                }	
            }
        }

    	
    	
    	for (int i = 0; i < word.length(); i++){
        	int t = 0;
        	for (int row = 0; row < NUM_ROWS; row++) {
            	for (int col = 0; col < NUM_COLS; col++) {
                	//check whether the word is in the board
                	if (this.board[row][col] == word.charAt(i)) {
                		t++;
                	}	
            	}
        	}
        	if (t == 0){
        		return null;
        	} 
        }
        
        return "True";
    }


    /**
     * Given the GameBoard instance's letter square, find
     * path/sequence the spells out wordToFind starting from
     * square (row, col), with the pathSoFar including this
     * current (row, col) if a path can be found. This is
     * meant to be a recursive method, therefore will require
     * one or more base cases and one or more recursive
     * cases.
     *
     * @param wordtoFind The word for which a sequence must
     * be found on the board. Note could possible be a single
     * character (which should be a base case). Also note
     * that sequence of calls to findPath should occur with
     * short and short strings in wordToFind.
     * @param pathSoFar The stack is use to keep track of 
     * (row, col) lettersquares on the path. Any call of this
     * method should directly perform at most one push and
     * at most one pop.
     * @param row Row index of square from which to start
     * looking for a sequence. (The assumption is that this
     * function is only ever called if the first letter in
     * word corrsponds to the (row, col) lettersequare).
     * @param col Column index of square from which to
     * start looking for a sequence.
     * @return true if a sequence can be found, false
     * otherwise.
     */
    private boolean findPath(String wordToFind, 
                             Stack<String> pathSoFar,
                             int row, int col)
    {
        if(wordToFind.length() == pathSoFar.search("(" + row + "," + col + ")")) {
        	return true;
        } 
        for ( int r = row - 1; r <= row + 1 ; r++){
        	for( int c = col - 1; c <= col + 1 ; c++){
        		if (r >=0 && r <= 3 && c >=0 && c <= 3 ){
        			if (r != row | c != col) {
        				if ( wordToFind.charAt(1) != this.board[r][c]){
        					continue;
        				}
        				if (pathSoFar.search("(" + r + "," + c + ")") != -1){
        					continue;
        				} else {
        					pathSoFar.push("(" + r + "," + c + ")");
        				}
        				if(findPath(wordToFind.substring(1), pathSoFar, r, c) == true){
        					return true;
        				}
        			pathSoFar.pop();
        			}
        		}
        	}
        }
        
        return false;
    }


    /**
     * Creates a few GameBoard instances and causes their
     * contents to be printed. This method should be used for
     * tests written by the student as they develop their
     * solution.
     */
    static public void main(String[] args) {
        String testBoard[] = {"wurg", "hsor", "heei", "isen"};
        GameBoard test01 = new GameBoard(testBoard);
        System.out.println(test01);

        GameBoard test02 = new GameBoard(300);
        System.out.println(test02);
        
    	System.out.println(test01.isWord("SOE"));
    	
    	
        
    }
}
